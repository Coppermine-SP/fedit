## III. textengine 모듈 설계

### A. 모듈 개요
textengine 모듈은 프로그램에서 텍스트 처리와 관련된 모든 역할 (파일 로드 및 저장, 텍스트 버퍼 처리)를 담당한다.

`main()` 함수는 명령 인수로 전달받은 파일 이름 스트링을 `te_init()` 함수의 파라미터로 전달하여 textengine 모듈을 초기화한다. 만약 명령 인수 없이 프로세스가 시작되었을 경우 NULL을 전달한다. 현재 텍스트 버퍼를 `te_buffer_save()`에 파일 이름 스트링을 전달하여 저장한다. 이 함수의 반환 값은 저장 성공 여부를 bool 타입으로 반환한다.

#

### B. 내부 자료 구조
이 프로젝트에서는 다중 커서를 지원하지 않기 때문에, 모든 입력이 하나의 커서 위치에서 클러스터하게 일어난다. 그래서 트리 구조와 같은 과도하게 복잡하고 메모리 오버헤드가 큰 자료구조 대신, 동일한 위치 근처에서 클러스터된 효율적인 삽입 및 삭제 작업을 허용하는 동적 배열 구조인 Gap Buffer를 textengine 모듈에서 사용한다. (이는 유명 에디터인 Emacs에서도 사용된다.)

Gap Buffer 자료 구조는 선형 자료형이며, 다음과 같은 기능을 가진다.
-	삽입:		`insert(char x)` – O(1)
-	삭제:		`delete()` – O(1) 또는 O(n)
-	커서 이동: `move_cursor(const char* pos)` – O(n)

</br>
<p align="center">
<img src="https://github.com/user-attachments/assets/0d78089f-883f-47c4-a48d-14f9248df079" style="width:60%">

</p>
<p align="center">Figure III: Gap Buffer 자료 구조의 동작 시각화</p>
</br>

Gap (여유 공간) 안에서의 삽입 및 삭제는 상수 시간에 이루어지고, 삽입을 시작하거나 완료하기 위해 Gap을 열거나 닫기 위해서는 모든 요소를 시프트해야 할 수 있기 때문에 O(n)이 소요된다. 만약 여유 공간보다 더 많은 문자를 삽입할 경우, 다시 확장한다.

즉, Gap을 여는데 O(n)이 한번 소요되고, 그 후에 Gap 안에서의 삽입, 삭제는 O(1)이 소요된다. 단, 여유 공간 밖에서의 삭제는 여전히 O(n)이다. Gap을 한 번 열면, 여유 공간 안에서의 삽입 및 삭제가 상수 시간에 이루어진다는 특성에 의해 동일 위치의 클러스터 된 삽입 및 삭제 연산에 대해 효율적이다.

#

### C. 문자 삽입과 삭제
